{{define "item"}}"{{.}}": {{if eq . "go"}}Go{{else if eq . "func"}}FunC{{else if eq . "context"}}ConTeXt{{else}}{{.}}{{end}}{{end}}
package forest

import (
	"embed"
	enc_json "encoding/json"
	"path/filepath"
	"regexp"
	"slices"
	"strings"
)

const (
	_ byte = iota

	NvimFirst   // fetch both, prefer nvim
	NativeFirst // fetch both, prefer native
	NvimOnly    // fetch only from nvim_treesitter
	NativeOnly  // fetch only from sitter repo

)

//go:embed grammars.json
var info []byte

var languageFuncs = map[string]func() *sitter.Language{ {{- range . -}}
        {{template "item" .}}.GetLanguage,
{{end -}}}

var queryFuncs = map[string]func(string, ...byte) []byte{ {{- range . -}}
        {{template "item" .}}.GetQuery,
{{ end -}}}

var (
	langNames []string
	grammars  []*grammar.Grammar
	// Making the colon optional is risky: most places use it AND
	// there are many places that do NOT use it and mean something else...
	rxInherits    = regexp.MustCompile(`^\s*;\s*inherits:?\s*(.*?)\n`)
	nvimRemaining = filepath.Join("internal", "queries", "nvim_remaining")
)

//go:embed internal/queries/nvim_remaining/*/*.scm
var remainingQueries embed.FS

// Lang returns the corresponding TS language function for name.
// Language name must follow the TS convention (lowercase, letters only).
func GetLanguage(lang string) func() *sitter.Language {
	return languageFuncs[lang]
}

// GetQuery returns (if it exists) the `kind`.scm query for `lang` language,
// using the DefaultPreference, resolving "inherits" directives, recursively.
// You should omit the ".scm" extension.
func GetQuery(lang, kind string, opts ...byte) (out []byte) {
	kind = strings.TrimSuffix(kind, ".scm") + ".scm"

	q := queryFuncs[lang]
	if q == nil {
		q = getQueryFromRemainingNvim(lang, opts...)
	}

	if q != nil {
		out = q(kind, opts...)
	}

	if len(out) == 0 {
		return
	}

	mx := rxInherits.FindSubmatch(out)
	if mx == nil {
		return
	}

	inherited := strings.Split(string(mx[1]), ",")
	for _, in := range inherited {
		out2 := GetQuery(in, kind, opts...)
		if len(out2) == 0 {
			continue
		}

		out = slices.Concat(out2, []byte{10, 10}, out)
	}

	return
}

func getQueryFromRemainingNvim(lang string, opts ...byte) func(string, ...byte) []byte {
	if len(opts) > 0 && opts[0] == NativeOnly {
		return nil
	}

	return func(kind string, _ ...byte) (out []byte) {
		out, err := remainingQueries.ReadFile(filepath.Join(nvimRemaining, lang, kind))
		if err != nil || len(out) == 0 {
			// log somewhere/somehow
			// fmt.Printf("unable to locate a %q query for %q\n", "highlights", lang)
			return nil
		}

		return
	}
}

func SupportedLanguages() []string {
	if langNames != nil {
		return langNames
	}

	for k := range languageFuncs {
		langNames = append(langNames, k)
	}

	return langNames
}

func Info(lang string) (gr *grammar.Grammar) {
	i := slices.IndexFunc(grammars, func(x *grammar.Grammar) bool {
		return x.Language == lang
	})
	if i < 0 {
		return
	}

	return grammars[i]
}

func init() {
	grammars = []*grammar.Grammar{}
	if err := enc_json.Unmarshal(info, &grammars); err != nil {
		panic(err)
	}
}

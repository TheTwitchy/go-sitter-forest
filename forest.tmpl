{{define "item"}}"{{.}}": {{if eq . "go"}}Go{{else if eq . "func"}}FunC{{else if eq . "context"}}ConTeXt{{else if eq . "terraform"}}hcl{{else}}{{.}}{{end}}{{end}}
package forest

import (
	"cmp"
	"embed"
	enc_json "encoding/json"
	"errors"
	"fmt"
	"path/filepath"
	"regexp"
	"slices"
	"strings"
)

const (
	_ byte = iota

	NvimFirst   // fetch both, prefer nvim
	NativeFirst // fetch both, prefer native
	NvimOnly    // fetch only from nvim_treesitter
	NativeOnly  // fetch only from sitter repo

)

//go:embed grammars.json
var info []byte

var ErrLanguageNotSupported = errors.New("language not supported")

var languageFuncs = map[string]func() *sitter.Language{ {{- range . -}}
        {{template "item" .}}.GetLanguage,
{{end -}}}

var queryFuncs = map[string]func(string, ...byte) []byte{ {{- range . -}}
        {{template "item" .}}.GetQuery,
{{ end -}}}

var (
	grammars grammar.Grammars
	// Making the colon optional is risky: most places use it AND
	// there are many places that do NOT use it and mean something else...
	rxInherits    = regexp.MustCompile(`^\s*;\s*inherits:?\s*(.*?)\n`)
	nvimRemaining = filepath.Join("internal", "queries", "nvim_remaining")
)

//go:embed internal/queries/nvim_remaining/*/*.scm
var remainingQueries embed.FS

// Lang returns the corresponding TS language function for name.
// Language name must follow the TS convention (lowercase, letters only).
func GetLanguage(lang string) func() *sitter.Language {
	return languageFuncs[lang]
}

// GetQuery returns (if it exists) the `kind`.scm query for `lang` language,
// using the DefaultPreference, resolving "inherits" directives, recursively.
// You should omit the ".scm" extension.
func GetQuery(lang, kind string, opts ...byte) (out []byte) {
	kind = strings.TrimSuffix(kind, ".scm") + ".scm"

	q := queryFuncs[lang]
	if q == nil {
		q = getQueryFromRemainingNvim(lang, opts...)
	}

	if q != nil {
		out = q(kind, opts...)
	}

	if len(out) == 0 {
		return
	}

	mx := rxInherits.FindSubmatch(out)
	if mx == nil {
		return
	}

	inherited := strings.Split(string(mx[1]), ",")
	for _, in := range inherited {
		out2 := GetQuery(in, kind, opts...)
		if len(out2) == 0 {
			continue
		}

		out = slices.Concat(out2, []byte{10, 10}, out)
	}

	return
}

func getQueryFromRemainingNvim(lang string, opts ...byte) func(string, ...byte) []byte {
	if len(opts) > 0 && opts[0] == NativeOnly {
		return nil
	}

	return func(kind string, _ ...byte) (out []byte) {
		out, err := remainingQueries.ReadFile(filepath.Join(nvimRemaining, lang, kind))
		if err != nil || len(out) == 0 {
			// log somewhere/somehow
			// fmt.Printf("unable to locate a %q query for %q\n", "highlights", lang)
			return nil
		}

		return
	}
}

func SupportedLanguages() []string {
	return grammars.Supported()
}

func SupportedLanguage(lang string) bool {
	return slices.Index(SupportedLanguages(), lang) >= 0
}

func Info(lang string) (gr *grammar.Grammar) {
	i := slices.IndexFunc(grammars, func(x *grammar.Grammar) bool {
		return x.Language == lang
	})
	if i < 0 {
		return
	}

	return grammars[i]
}

func init() {
	if err := enc_json.Unmarshal(info, &grammars); err != nil {
		panic(err)
	}

	if err := ft.load(ftDetect); err != nil {
		panic(err)
	}

	// TODO: Move this to a better place (load() itself? TBD)

	isDigit := func(r rune) bool {
		return r >= '0' && r <= '9'
	}

	// We need to place the ones ending in digits at the front (to favor them)
	// as digit is one of the separators, i.e.:
	// - we want to pick python for `python`, `python2`, `python3`, etc. BUT
	// - we want to pick json5 for json5 (ok bad example as it's not an interpreter,
	//   but you get the idea).
	interpreters := append(ft.shebangs(), SupportedLanguages()...)
	slices.SortFunc(interpreters, func(a, b string) int {
		la, lb := rune(a[len(a)-1]), rune(b[len(b)-1])

		if isDigit(la) && isDigit(lb) {
			return cmp.Compare(a, b)
		} else if isDigit(la) {
			return -1
		} else {
			return 1
		}
	})

	shebangRx = regexp.MustCompile(fmt.Sprintf(`^#!.*(?:/|/env"?\s+|/env"?\s+.*\s+)(%s)(?:"|\d|\s|$)`,
		strings.Join(interpreters, "|")))
}
